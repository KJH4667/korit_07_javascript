## Object 객체
내장 객체 (Built-in Object)는 브라우저의 JS엔진에ㅡ 내장된 객체를 의미함. 모든 Object 객체는 모든 JS의 루트 객체.

String, Number, Date, Array, Math, etc...


1. length 
```js
let txt = 'abcd';
let txtLength = txt.length; 
console.log('문자열의 길이는 ' + txtLength + '입니다')

```

2. indexOf()
문자열 안에 특정 문자열이 존재하는지를 찾고, 문자열이 시작되는 index를 반환하는 method. 
- 문자열을 찾지 못하면 -`를 return


4. slice ()
매개변수로 시작 위치 / 종료 위치를 줬을때 문자열의 해당 부분을 잘라내서 return하는 mrethod 

5. substring()
- slice()랑 다 똑같은데 마이너스 인덱스가 없습니다. 

6. substr()
- slice()랑 비슷한데 두번째 매개변수가 한계값 미만을 지시하는게 아니라, 첫번째 매개변수로부터의 문자 개수를 의미합니다. 
- 얘는 마이너스 인덱스가 또 있습니다. 


7. replace() 
- 문자열 내의 특정 문자열을 지정한 문자열로 바뀌는 함수 
- 마치 vs code 상에서 컨트롤 + r 누르면 문자열 검색해서 바꿀수있는거랑 동일한 기능입니다.

- 정규식과 조합했을때 다양하게 replace() 적용이 가능합니다.
- `/i`: inseneitive - 대소문자 구분 안함
- `/g`: golbal - 일치하는 문자열 전체 replace()적용


8. toUpperCase(), toLowerCase()

9. concat ()
- 두 개 이상의 문자열을 하나의 문자열로 합치는 method

10. trim()
- 문자열 앞/뒤 공백을 모두 제거하는 함수 
- DB에 공백이 있으면 조회할 때 실패하는 경우가 있어 공백 제거하고 조회하는 일이 많습니다. 


11. charAt ()
- 문자열에서 특정 인덱스에 해당하는 문자 하나를 반환하는 method 


12. charCodeAt ()
- 문자열에서 특정 인덱스에 해당하는 문자의 "유니코드"값을 반환

13. split()
- 문자열 내의 특정 기준을 가지고 문자열을 분리하여 "배열"로 반환하는 method 


14. startWith(), endsWith()
- 문자열의 시작 혹은 끝이 매개변수로 전달된 값으로 이루어져있는지 확인하는 method 

- 실무 사례
startsWith('https')를 해서 보안이 뛰어난 https로 접속했는지를 확인합니다. 이상의 경우 false가 나오게 되면 http로 접속했다는 뜻이 되겠네요.
endWith()의 경우에는 특정 파일 확장자인지를 체크하는 용도로 쓰입니다. endsWith('.pdf'); 와 같은 방식입니다.


## Number 객체
02_js_number_methods.html


1. toString() - 설명 생략
2. toFiexd()
- 소수점 몇번째 자리까지 보여줄지를 결정하는 method.
- 매개변수로 소수점 자리수 사용.
- 반올림 


3. toPrecision()
- 2번과 다르게 정수와 소수를 포함해서 몇 번째 자리까지 보여줄지 결정하는 method 


4. parseInt()
- 전역 함수로, 정수로 반환.
문자열의 시작이 number면 number로 반환 


5. parseFloat()
- 전역 함수로, 부동소수점으로 반환 


## Array 객체
03_js_array_method.html 


1. toString()
- 배열 내의 element들을 ',' 기준으로 모두 결합하여 하나의 문자열로 return 


2. join()
- 배열 내의 모든 문자를 매개변수로 지정한 문자를 이ㅛㅇ하여 element들을 구분함. '배열명.join('/')' 라고 가정했을 경우 결과값은 요소1/요소2/요소3... 으로 기준으로 결합됨 


3. pop()
- 배열에서 마지막 데이터를 제거하고, 마지막 데이터를 return 

4. push()
- Java Collection 에서 list / set 에서 .add()와 같습니다. 어제 해봤습니다. 

5. shift()
- pop()과 달리 첫번째 element를 제거하고 그 element를 return 

6. unshift()
- 배열의 맨 앞에 element를 추가하고, 배열의 index를 return 

- 굳이 맨 앞에 추가하는 method가 따로있는 실무 사례 
 - HTML 문서 작성 시에 `<select>` 태그 구현할 때, 예를 들어서 DB에서 지역 목록 가져오고, 가져온 지역 목록을 `<select>` 태그의 `<option>` 태그로 추가하려고 할때, `<select>` 태그의 `<option>`태그로 추가하려고 할때, `<select>` 태그에서 사용자에게 제일 먼저 보이는 옵션이 '선택하세요'와 같은 정보상 글입니다. 이럴떼, DB에서 '선택하세요'가 있지않을테니까 unshift("지역을 선택하세요"); 로 배열에 추가하는 방식이 있습니다.
 - 혹시 햇갈리신다면 html_css 파일에서 컨트롤 + 쉬프트 + F `select` 검색해보세요.


 7. 배열 element 변경
 ```js
 let subs = ['국어', '수학', '영어', '자바', '자바스크립트'];
 sub [0] = '파이썬';
 
 ```



 8. splice()
 - 새로운 element를 특정 위치에 추가하는데, 기존 element르 삭제도 가능.


 ```js
 let fruits2 = ['Banana', 'Orange', 'Apple', 'Mango'];
fruits2.splice(2, 0, 'lemon', 'kiwi');
console.log(fruits2); // 결과값: ['Banana', 'Orange', 'Apple', 'Mango']
 ```

 splice(2, 0, 'Lemon', 'kiwi' )의 매개변수 목록

 1. 2- 새로운 element를 추가할 인덱스 넘버
 2. 0- 첫번째 매개변수에 해닫하는 인덱스에서 element를 추가하기 전 에 삭제할 element 수
  - 저희는 0으로 지정했으니까 아무것도 삭제되지 않았습니다. 

  3. 'Lemon', 'kiwi' ... etc - 나머지 매개변수는 추가할 element들에 해당합니다. 


  9. concat()
  - 2개 이상의 배열을 하나의 배열로 결합

  10. slice()
  - String 에서와 동일
  - 근데 배열 형태로 return

  11. sort() -> 오름차순 정렬입니다.
  12 reverse() -> 내림차순 정렬입니다.
   - Java처럼 골치 아프게 안해도 됩니다. 


   13. filter ()
   - 배열에서 특정 조건을 만족하는 배열의 element 만을 찾아서 "새로운 배열"로 return 합니다.
   자주 사용하는 method

   - 특정 조건을 만족하는 데이터만 추출해내는 프로그램을 작성하는 경우가 빈번한데, 이때 filter()를 쓰기 때문에 필수적이라고 할 수 있습니다.

   형식
   `배열명.filter(콜백함수[, index [, 배열]])[,thisArg])`

   filter() method에는 특정 조건을 체크하는 callback함수를 매개변수로 전달합니다. 여기서의 callback 함수는 배열의 각 element를 시험할 함수에 해당합니다. 시험을 통과(true)하게 되면 element를 그대로 유지하고, false라면 버리게 됩니다. 즉 true인 element들만 모아서 "새로운 배열"을 생성합니다. 

   callback함수의 매개변수는 -element- 처리할 현재 element(기존 배열의 element를 의미합니다.)
   -index(optional)- 처리할 현재 element의 인덱스
   -array(optional) - 배열전체


   ```js
   js 파일내용 복사 붙혀넣기
   ```


   14. map()
   - 배열 내의 element가 object일때 배열에 담긴 object를 새로운 형태의 object로 변환하여 배열로 return 


15. reduce()
- 배열에 담긴 element 를 하나씩 순화하며 callback 함수의 실행값을 "누적" 하여  return한ㄴ method. 누적 결과 값은 숫자, 문자, 객체 모두 가능.

- 주로 배열 내의 element 데이터와 합계를 구할때 많이 사용됩니다.

- 배열 내의 element 가 객체인 경우 누적값을 구하고자 하는 object의 property를 참조해서 씁니다.(persons 라면 persons[0].score가 되겠네요. )



reduce() method 내의 callback 함수는 4개의 매개변수를 가질수 있습니다.(주로 2개만 쓰고 나머지는 optional입니다.)

- 1번 매개변수: accumulator(누적값 - 저희는 total 썼습니다)
- 2번 매개변수: currentValue(배열의 현재 element, 저희는 currnetValue)
- 3번 매개변수 : currentIndex(현재 index 넘버)
- 4번 매개변수 : arr(배열)


## Set 객체

2. Set 생성자
```js
let mySet = new Set();
```

2. add() - Java와 같습니다.

3. get() - java에서의 맵이름. get("키")
3. has() - 특정 데이터가 있는지 확인합니다. return boolean
4. delete() - 특정 데이터 삭제
userMap.delete('name');




### JAvaScript Object vs. JavaSCript Map

1. Object는 key를 string으로 지정해야 하지만 Map은 다른 타입도 가능합니다.
2. Object는 몇개의 데이터가 담겼는지 수동 계산해야 하지만 Map은 맵이름. size로 크기를 알수있습니다.
3. Object는 저장된 데이터를 for-in(어제 수업)으로 읽었을때 순서를 보장하지 않지만 Map은 데이터를 저장한 순서대로 읽어옵니다.
(근데 Java Map은 또 순서를 보장하지 않습니다)

## JSON 객체
04_js_JSOM.html

- 데이터를 저장하거나 전송할 때 많이 사용되는 "경량"의 데이터 교환 형식입니다. 

- 다수의 플랫폼에서 사용됨.

1. 서버와 클라이언트 간의 데이터 전송시 많이 사용.
2. JavaScript의 Object객체 표기법과 매우 유사
3. JSON 데이터는 JavaScript JSON 객체의 parse() method를 이용하면 JavaScript Object 객체로 변환하여 사용 가능
4. 프로그래밍 언어와 상관없이 사용할 수 있는 데이터 교환 형식
5. 대부분의 언어에서 JSON 데이터를 처리할 수 있는 라이브러리 제공(Java는 GSON 이었습니다)


### 중요 내장 함수 목록
1. JSON.stringify(Object명) - 데이터를 서버로 전송하기 위해서 데이터 형태를 문자열로 변환(이유: 가벼워서)해줍니다. 여기서는 JavaScript 객체를 문자열로 변환해줍니다. 

2. JSON.parse(JSON명) - 서버로부터 응답받은 JSON데이터를 JavaScript Object의 객체로 변환해줍니다. 

## Window 객체
05_js_window.html
window 객체는 전역(global) 객체입니다. 현재는 브라우저라고 생각해도 무방합니다.

1. alert() - 윈도우 화면에 경고 메시지를 출력 
2. confirm() - return type boolean

```js
if(confirm('정말 삭제하시겠습니까?')) {
  // 삭제 로직
  console.log('삭제');
}
```


3. prompt() - 문자열을 입력받을수 있는 함수
```js
let txt = prompt('비밀번호를 입력하세요');

if(txt === null) {
  // 취소 버튼을 눌렀을 때의 로직
} else if (txt === '') {
  // 아무값도 입력하지 않고 확인 버튼 눌렀을때의 로직
} else if (txt !=='') {
  // 어떤 값을 입력하고 확인 버튼을 눌렀을때.
  //그럼 여기에 비밀번호 일치 했을때와 아닐때의 조건문이 추가로 들어가야겠네요.
}
```

4. open() - 윈도우 새창 / 새 탭으로 지정한 url을 오픈하는 함수

5. setTimeout() / clearTimeout()
- setTimeout() 함수는 두번째 매개변수로 지정한 시간 간격 이후에 첫번째 매개변수에 정의한 함수를 실행시킴. callback 개념을 알아야 써먹을수 있습니다. 

- clearTimeout() - setTimeout() 함수에서 정의한 함수가 실행되지 않았을때 , setTimeout()의 콜백 함수를 실행시키는 것을 중지할때 사용.

- 밀리초 사용합니다.

ch03_js_applied


# JavaScript 고급 문법이지만 front에서 그냥 다 쓰는 

## Default Function Parameter
- 함수를 호출할때 예를 들어, `function(mesage) { return 어쩌고 };` message가 비어있는 상태가 되면, 호출 단계에서 argument가 없기 때문에 오류(undefined)가 발생합니다.
만약에 매개변수가 함수 내에서 특정 기능을 구현하기 위해서 반드시 요구된다면, "아무런 값이 없을경우"함수를 호출할때마다 체크를 해야할 겁니다. 

```js
function say(message) {
  if(messgae !== undefined) {
    console.log(message);
  } else {
    console.log('매개변수가 입려되지 않았습니다.');
  }
}

say(); // argument 없이 함수를 호출했을 경우에는 
// 결과값: 매개변수가 입력되지 않았습니다. 

```
Default function parameter 를 지정하게 되면, argument없이 함수를 호출했을때, 미리 설정해둔 기본값으로 함수를 호출하여 오류가 발생하지 않게끔 하는 사전 작업.

```js
function say(message='매개변수가 입력되지 않았습니다') {
console.log(mesage);
}

say();

```

## Rest 
일반적인 함수 선언식으로 함수에 따라 몇 개의 argument가 요구되는지 미리 선언합니다. 매개변수 2개 짜리로 정의하면 함수 호출 시에 2개의 argument를 요구하고, 4개짜리를 정의하면 함수를
호출할때 4개의 argument를 요구하겠죠. 근데 우리가 3개 짜리로 쓰고 싶으면 어떡해야하냐, 뭐 이런 문제가 있습니다.

문제 사례
```js
function sum(x1, x2) {
  return x1+x2l
}

sum(5,7);

function sum(x1, x2, x3, x4) {
  return x1+x2+x3+x4;
}

sum(5, 7, 8, 10);
```
하지만 3개 짜리 연산은 불가능해서 sum(1, 2, 3, 0); 같은 꼼수를 써야만 할겁니다. Rest Parameter의 개념은 몇개의 매개변수가 전달될지 모르는 상황에서 매우 유용합니다. 

Rest Parameter 적용 예시

```js
function sum(...args) { // 이렇게 매개변수를 선언하면, 함수 호출 시에 매개변수 개수에 상관없이 할당 가능하고, 이렇게 할당된 값은 "배열"로 저장 
let total = 0;
//배열로 저장되기 때문에 element를 추출하여 합 연산을 해야함.
for (let x of args) {
  total += x
}
return total;
}

sum(1,2,3);
sum(2,4,56,88,12312412535);

```

## Arrow Function(LAmbda Expression의 JS ver.)
기존의 함수 표현 방식들
1. 함수 선언식
```js
function hello(name) {
  return 'hello' + name;
}

```
2. 함수 표현식
```js
const hello2 = function(name) {
  return 'hello' + name;
}
```
hoisting 여부로 인해 # 1, # 2 방법이 생겨났습니다.

화살표 함수는 함수를 정의하는 비교적 최근 방법입니다.(저희는 람다에서 배웠지만 여기서 훨씬 많이 써먹습니다). 화살표 함수를 사용해서 함수를 정의하면 구문이 짧아진다는 장점이 있습니다. 단점은 람다에서 봤던것처럼 너무 복잡한 로직을 구현하기는 힘들다는 점입니다. 

3. 화살표 함수
```js
// full form
const hello3 = (name) => (return 'Hello' + name);

// 매개변수가 하나라면 소괄호(())를 생략할 수 있다
const hello4 = name => (return 'Hello' +name);

//실행문이 한줄이라면 return / 중괄호 {{}}를 생략할 수 있다.
const hello5 = name =>  'Hello' + name;

// 매개변수가 없다면 빈 소괄호를 사용함.
const hello6 =() => 'Hello, there'; 

```

## Template Literals
```js
// 1.기존 작성 방식
function hello(name) {
  console.log('Hello' + name + '환영합니다');
}

// 2. 템플릿 리터럴 적용 방식
function hello2(name) {
  console.log('Hello ${name}. 환영합니다!');
}

```

2의 장점은 중간에 ++ 기호 넣는다고 오류 발생할 확률이 적다는 점이빈다. 단점은 대충 보면 얘가 

01_js_applied.html


## Object Literal Syntax Extension

```js
let fName = 'Josh';
let lName = 'Smith';

let person = {
  fName: fName,// 앞은 person의 property고 뒤는 433번 라인의 변수죠.
  lName: lName,
}

// 2. Object Literal
let type = 'student';
let score = {
  [type]: 'Josh',.
  score:92,
}
```

2. 번에서 Object의 key에 []가 있다는 점을 확인할 수 있습니다. Js객체의 Key를  []로 감?싸게 됐을때는 '할당된 변수 값'을 의미하게 됩니다. 이상의 장점으로는 Js객체의 key를 동적으로 생성 가능합니다. 

## Spread Operator (JS에서 처음 배웁니다.)
- 배열, 문자열 등 반복가능 객체 형태의 데이터를 elemenet 하나하나 분해해서 사용할수 있도록 함.

## Object Destructuring (객체 구조분해)

## Array Destructuring(배열 구조분해)

# JS HTML DOM
ch04_js_dom
- DOM(Document Object Model)
- JS는 HTML 문서의 모든 요소에 접근하여 변경할수 있습니다. 간단하게는 `<table>` 태그 내에 `<td>`를 추가할수 있을겁니다.

1. 모든 HTML element
2. HTML 태그의 속성(특성)
3. CSS 스타일
4. HTML element 및 속성을 제거
5. 새로운 HTML element및 속성을 추가
6. 페이지 내에 존재하는 모든 HTML이벤트에 대한 반응
7. 새로운 HTML 이벤트 추가

## DOM Element

01_domelement.html 


JS에서 HTML element에 대한 다양한 제어를 위해 가장 먼저 할 일은 HTML element에 대한 접근입니다. JS상에서 HTML요소를 찾는 방법은,

1. id 값을 통해,
2. 태그명을 통해,
3. class 명을 통해,
4. CSS의 선택자 개념을 통해 찾을수 있습니다.

-HTML element의 id로 찾기
 - HTML태그의 id 속성은 고유값이기 때문에 단일한 결과가 나옵니다. 
 - 만약에 id가 정확하다면 JS객체의 형태로 HTML element가 return 
 - 일치하는 id가 없다면 null return

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM element</title>
</head>
<body>
  <input id="userid" type="text">
  <p>태그명을 사용해서 HTML 요소를 찾습니다. document.getElementById</p>
  <script>
let element

  </script>
</body>
</html>

```

- id값을 통한 추출과 태그명을 통한 추출에서의 차이점은 id는 고유값인데 반해 태그는 한 HTML 문서 내에 복수로 있을 수 있으므로, return 타입이 JS객체 하나짜리가 아니라, JS객체를 element
로 하는 배열이 return된다는 점입니다. 

- 이를 명확히 확인하기 위해서 method 명을 보시면 getElement's'ByTagName 이라고 명시되어있는 점을 알수있습니다.

- 클래스명을 통한 HTML 요소 찾기
- CSS 선택자들을 이용한 HTML 요소 찾기


## DOM Attribute
## HTML 내용 변경
03_js_html.html
1. innerHTML
 - HTML의 특정 위치에 새로운 HTML을 삽입할 때 사용.

 2. innerText
 -1과 비슷하지만 텍스트 내용만 삽입 가능함.

## DOM event(클릭 이벤트 등)
웹 페이지를 이용하면 웹 화면과 사용자 사이에 상호작용이 나타납니다. 예를 들어, 
1. 버튼을 클릭한다든지,
2. 마우스를 스크롤 한다든지,
3. 검색을 위해 검색 키워드를 input 창에 입력한다든지 하는 행동 등.
이상의 모든 상호작용을 event 라고 합니다.

### click 이벤트(onclick) - 골치아픈게 react 에서는 onClick입니다. 
마우스 좌클릭할때 발생하는 이벤트 입니다. 검색 / 저장과 같은 버튼을 클릭하면, 이때 클릭 이벤트가 발생합니다.

대표적인 예로 `<button>` 요소에 클릭 이벤트가 일어나는지 감시하고, 클릭 이벤트가 일어나는 순간 특정 함수를 실행시켜야 겠네요.
이때 `<button>` 태그 내의 onclick 속성을 이용하여 처리할 수 있습니다. 

- 검색 버튼을 클릭하면 검색 기능이 실행되어 화면에 검색 결과를 출력, 
- 저장 버튼을 클릭하면 사용자가 입력한 데이터르 서버로 보내고 DB에 저장,
- 메뉴 버튼을 클릭하면 해당 메뉴로 이동 등 

04_click_event.html

### change 이벤트 (onChange)
- 값이 변경되었을 때 발생하는 이벤트
- 대표적으로는 `<select>`, `<input type = "checkbox">`, `<input type = "radio">` 에서 발생합니다. 

05_change.html

### Key 이벤트 (onkeydown, onkeyup, onkeypress)
key 이벤트는 사용자가 입력창에서 (`<input>`태그에서) 키보드를 입력할 때 발생.
사용자가 키를 입력하면 ketdown -> keypress -> keyup의 순서로 이루어집니다. 

input type = "text"에 keydown / keypress / keyup 이벤트를 모두 받을수 있도록 설정하고, 순서를 검증하겠습니다. 

06_key_event.html

# JS 주요 Web APIs
## LocalStorage / SessionStorage 

까지 하고 배운거 응용해서 Todo List JS 만들기 해보겠습니다. 