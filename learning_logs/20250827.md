20250827 자바 스크립트 시작함

1. JavaScript (ES6) code snippets -> 자바 스크립트 코드 자동완성 프로그램
2. ESLint: ES + Lint로 ES ECMA Script, Lint는 소스 코드를 분석하여 프로그램 오류, 버그, 스타일 오류, 의심스러운 구조체의 표시를 달아놓는것으로, 그냥 JS문법 오류 체크해주는 애라고 생각하시면 됩니다. 

터미널에서 새로운 버젼 확인방법: "node -v" 입력하면된다. 


# JavaScript 기본문법
ch01_js_basic / 01_js_location.html

## JavaScript 
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Java Script 코드의 작성 위치</title>
  <script>
// 여기에 뭘 쓰고 주석처리를 동일하게 하면 이렇게 //2개가 뜹니다. 주석처리 방식이 다름. 
// 1. 첫번째 위치로 head태그 내에 script 태그를 생성하여, 태그 안에 작성 가능
document.write('자바스크립트 head 태그에 위치 <br>');
  
  </script>
  <script src="./01_js_location.js"></script>
</head>
<body>
  <!-- 여기에 내용을 작성하고 컨트롤+/ 하면 주석처리가 됩니다. -->
   <script>
    // 바디 태그 안에서도 스크립트를 적용할수가 있다. 
    document.write('자바스크립트 body 태그에 위치<br>');
    // 3. 01_js_location.js
   </script>
   <script src="./01_js_location.js">

   </script>
</body>
</html>

1. head 태그 내에 script 태그 생성후 직접 js 코드 작성 
2. body 태그 내에 script 태그 생성후 직접 js 코드 작성
3. 별개의 .js파일을 생성후 head / body 태그에 script src 부분에 .js파일의 경로 삽입


-참고: 추가 확장 프로그램 Code Runner를 설치
 -이거 설치하면 .js에서 컨트롤+알트+N 을 누르면 마치 인테리제이 에서 자바 코드 실행하는것 처럼 콘솔창에 코드 실행 결과가 나옵니다. 

 -문제점은 html 문서와 연동해서 읽는 것이 아니라 .js 파일 자체만 읽기 때문에 임시 방편이고, 미리 보기의 경우에는 개발자 도구를 확인할 수 없기 때문에 console.log를 확인할 수 없어서 
 -console과 document를 둘다 사용하는 겨우에는 live server를 활용하여 크롬 개발자 도구의 console과 문서 화면을 확인할 필요가 있습니다. 그래서 수업에서는 세가지 방법을 다 소개했씁니다.

 console이라도 하는 객체의 .log메서드가 어떤 역할을 하는지
 document라고 하는 객체의 .write가 어떤 역할을 하는지 확인할 수 있었습니다.  


 ## 변수와 상수
 1. 변수(variable): 데이터를 담는 그릇 / 바구니 / etc... js에서는 변수에 literal 뿐만이라 개체도 담을수 있구요, 그리고 _함수_도 담을 수 있습니다. 
 2. 상수(const): 변화하지 않는 값을 가지고 있는 변수

 ## 변수 선언 형식
 형식 
 선언자 변수명 = 데이터;
 ```js
var greeting = 'Hello, World!';
console.log(greeting);
 
 ```
 - Js변수 선언 규칙
 1. 변수명은 문자(특수문자 재외), 숫자, _(인더스코어), $(달러 기호)를 포함하여 만들수 있다.
 2. 변수명은 숫자로 시작할수 없다.
 3. JS 예약어는 사용할 수 없다(document를 변수명으로 짓지 못한다는 뜻입니다.)
 4. 대소문자를 구분한다.
 5. 스크립트 표준인 ECMA Script에서는 변수명 / 함수명은 카멜케이스 를 사용하고, 클래스명, 생성자 명에는 파스칼 케이스를 사용할 것을 권장합니다. 

 ### var 선언자
 Js 사에서는 데이터 타입(자료형)에 관계없이 변수를 저장할때 var 선언자와 let 선언자를 사용할 수 있음. 실무에서는 주로 let을 사용합니다. 그런데 부산에서는... var도 여전히 쓰는것 같아서 얘부터 시작합니다. 

 ```js
 var x = 5;
 var y = 6;
 var z = x + y; //11이 저장되겠죠.

 ```

 이까지는 뭔가 int 비슷한거구나, 근데 위에 쓴거 보니깐 String 대신해서 그냥 자료형 안쓰고 처음 선언할때마다 var 쓰면 되는구나, 라고 생각하실수 있습니다. 

 ```js
 var x = 5;
 var y = 6;
 var z = x + y; 



 var x = 7;
 z = x + y // 13이 저장될겁니다.
 
 ```
 근데 94번 라인과 95번 라인을 보면 X라는 변수에 다시 선언자를 썼고, 95번 라인에서는 한번 선언된 변수 z이기 때문에 선언자를 사용하지 않았음을 확인할수 있습니다. 근데 둘다 오류가 발생하지 않습니다. 이상의 경우 생기는 문제점은 동일한 변수명에 전혀 다른 기능을 넣었을때, 예를 들어 A 개발자가 var x 선언해서 어떤값을 집어넣었고, 그걸로 기능 실행하다가, 협업하는 B개발자가 var x를 재선언 해서 다른값 집어넣고 새로 넣은 x 데이터를 기준으로 기능 실행하면 중간에 오류가 발생하겠죠. 테스트 중간에서는 확인이 안됩니다. Java처럼 컴파일링을 하는게 아니었읜까요. 그리고 심지어는 내가 그냥 사용한 변수명이 외부 라이브러리 변수명이랑 동일해도 문제를 체크하는게 불가능합니다. 


```js
console.log(a);
var a = 10;
console.log(a);
```


 그리고 위 의 코드라인도 오류가 발생을 안합니다. 추후 hoisting 개념으로 설명드릴 예정입니다. 하지만 이미 많은 웹 사이트들이 var를 사용하여 코드를 작성해서 현재 서비스가 진행중이기 때문에 var를 갑자기 금지 시키는 것은 불가능하고, 그래서 ES6부터는 let이라는 선언자를 추가로 만든 후에, 이를 사용하는 쪽은 권장하는 방식으로 개선이 이루어지고 있습니다. 

 ### let 선언자 
 ES6 이후 추가된 선언자로, 사실 다 동일합니다. var의 문제점을 해결하기위해 등장했기 때문에 Java를 배운 저희는 int / String / double 등등을 대신해서 let을 쓰면 된다고 생각하셔도 좋습니다. 
 
 1. 재대입을 할때 또 let 을 쓰면 오류발생
 2. 실행되기 때문에 

 ```js
 console.log(a);
 let a = 20;
 console.log(a);
 ```
 와 같은 방식으로 작성하면 오류 140번 라인에서 오류 발생. 


 ### const 선언자(상수)
 마찬가지로 ES6에 추가된 선언자로, 상수(constant)는 변화하지 않는 변수를 의미합니다. 
 Java를 수업할때는 웬만하면 final을 쓰지 않았던 것에 반해 js에서는 웬만하면 const를 쓰라고 권장하는 편입니다. 그러면 절대로 값이 안바뀌니까 웹 서비스 상에서의 유연성이 없지 않느냐 싶을수 있는데 이게 또 백엔드 배우고 js배우면 뇌정지 오ㅓ는 부분중 하나입니다. 예시는 html과 섞어서 쓸때 보여드리도록 할 예정입니다. 

 ```js
 const x = 3;
 const y = 4;
 const z = x + 7;

 s = 5; // 오류발생
 ```
 그럼  const를 어떨때 쓰냐면, 애플리케이션 내에서 날짜를 보여주는 화면이 있다고 가정했을때, 
 1. 20250807
 2. 2025_08_27
 3. 2025 / 08 / 27
 4. 2025.08.27
 등을 예시로 들수 있습니다. 그런데 특정 페이지에서는 1번 방법이고 다른 페이지에서느 3번 방법을 사용하진 않을거고 동일한 웹서비스 내라면 하나의 양식으로 날짜를 출력해줄겁니다. 이상과 같은 경우에 날짜 포멧자체를 const로 선언합니다. 

 ```js
 const DATE_FORMAT = 'yyyy-mm-dd'; //와 같은 방식으로요.
 ```
 그러면 DATE_FORMAT이 고정되어있으니까 여기에 2025와 08와27을 대입하는게 불가능하지 않냐고 라고 질문하면 이제 골치아파 진다고 할수있습니다. 


 ## 데이터 타입
 ### 기본 자료형
 1. string 
 2. number(숫자 전체로 정수 실수를 가리지 않음)
 3. boolean
 4. undefined
 5. null 
 6. symbol

 #### string -> 넘어가겠습니다. js에서는 제가 그냥 ''로 쓸 예정입니다. 

 ```js
 console.log("제이름은 '안근수' 입니다");
 console.log('오늘점심은 뭐먹지? "짜장면!"');

 let name1 = "John Doe";
 let name2 = "John Doe"; // 둘다 가능한데 ''를 쓸 예정입니다. html과의 햇갈리지 않도록 
 ```
 #### number -> int / short / long / double / float 다 퉁쳐서 number 입니다.
 #### boolean -> 넘어가겠습니다. 


# undefined

- 료형이면서 동시에 데이터 값에 해당함. 정의되지 않음. 을 의미하고, 변수를 선언하고 아무런 값을 할당하지 않으면 undefined가 자동 할당됩니다.
null
null도 undefined처럼 자료형이면서 데이터 값에 해당하는데, 둘 다 변수에 값이 없는 상태를 의미합니다. 그런데 어떤 차이점이 있냐면,

undefined는 웹 브라우저 상에서 JS를 실행할 때 값이 할당되지 않은 변수에 대해서 자동으로 undefined를 할당합니다. 개발자가 아니라 브라우저 엔진이 할당하고 리턴해주는 것인 반면에,

null의 경우는 개발자가 평가해서 사용합니다. 선언된 변수에 대해서 아직 어떤 값을 할당할지 모르거나 어떤 데이터 타입이 할당될지 모르는 경우에 _개발자가 명시적_으로 null을 대입해두는 것을 의미합니다.

변수에 null을 할당하면 변수가 이전에 참조하던 값을 더 이상 참조하지 않게 되기 때문에 메모리 효율성이 향상됩니다. Java의 경우에는 garbage collector가 있었기 때문에 오랫동안 변수 참조를 하지 않으면 알아서 제거되는 것처럼 JS도 일정 주기를 기준으로 메모리 공간을 확보하게 되는데 이때 null을 확인하게 되면 더이상 해당 변수에 대한 참조를 하지 않습니다.

## symbol
- ES6에 추가된 새로운 자료형으로, 추후 설명 예정(웬만하면 잘 안쓰긴 할겁니다).

### 객체(Object)
- 추후 더 자세히 설명하긴 하겠지만 자료형 개념으로서의 Object에 대해서 설명합니다. JS의 모든 것은 객체로 이루어져있습니다. 하지만 데이터 관점에서 사용하는 것은 Object와 Array입니다.
Object
object는 키(key)-값(value) 쌍으로 데이터를 저장합니다. 예시

 ```js
 const person = {
fisrNmae: 'jone',
lastName: 'Doe',
age: 20,
eyeColor: 'blue'

 };
 
 ```
 앞부분이 key고 뒷부분이 value 이빈다. 그리고 JS상에서의 키-값 쌍을 property라고 합니다.

 - 수정방법

 ```js

 const person = {
fisrNmae: 'jone',
lastName: 'Doe',
age: 20,
eyeColor: 'blue'
};

// 객체의 출력
console.log(person);


// 객체의 property 수정방법 # 1
person.firstName = '일';  // 이건 Java에서의 field 수정법인 것 같죠
person.lastName = '김';   // access modi


// // 객체의 property 수정방법 # 2
person['eyeColor'] = 검은색;  // 이건 Java에서의 Map수정 방법인것 같죠
console.log(person);
```

### Array(배열)
하나 이상의 데이터를 하나의 변수명에 관리하기 위한 방법으로, 이를 굳이 학술적으로 풀어 쓰면 하나의 단일 참조(single reference)를 통해 다수 값을 확인 가능한 구조입니다. 배열에 저장된 데이터의 특징은 _순서_를 갖는다는 겁니다.(아까 console.log(person)에서는 properties에 순서가 없었습니다.)

형식
```js 
const cars = ['Hyundai', 'kia', 'Ford', 'Nissan']; 

```
Java와의 차이점은 {}이냐 []로 들수 있습니다. 나머지는 거의 동일한데, 

```js
console.log(cars[0]);
```
으로 출력 가능합니다.
- element 값 바꾸는 방법
```js
car[1] = 'Honda';
console.log(cars[1]); // kia 아니고 Honda 출력. 1번지가 kia지만 선언을 바꾸니깐 바꾼값이 출력되나보다.
```

### typeof 연산자
Java는 처음 변수 선언할때 자료형을 명시하기 때문에 필요없는 개념에 가깝긴한데, JS는 현재 변수에 어떤 자료형이 들어가있는지 확인해야할 필요가 있습니다. 이상의 경우 사용하는 연산자 입니다.


```js
let x = '안녕';
let y = 30;

//typeof 사용법
console.log(typeof x);  //string 
console.log(typeof y);  // number

console.log(typeof {x:1 , y:2});  // object
console.log(typeof {1,2,3});      // object
console.log(typeof null); 

```

JS에서는 배열도 object에 해당합니다. 


## 연산자(Operator)

### 할당 연산자
 - 연산 결과를 = 왼쪽에 있는 변수에 대입할때 사용하는 연산자들로, +, -, *, /, % 까지는 Java와 동일.  근데 **가 있습니다. 

 - ** 지수 할당 연산자 : n 제곱을 의미합니다. 


 ```js
 let x = 2;
 let y = 3;
 z = x ** y;  // 2의 제곱을 의미합니다. 2^3
 console.leg(z); // 8
 ```

 #### 복합 연산자 
 +=, -=, *=, /=, %=, **=

 ```js
 let x = 3;
 let y = 2;
 console.log(x%=y);   // x = x % y;

 let a = 5;
 let b = 2;
 console.log(a**=b)    // a = a ** b -> a = 5**2 = 5^2 = 25(5의 제곱)
 ```

 #### 비교연산자

 ```js
let a =3;
let b ='3';

console.log(a==b); // 결과값이 true
console.log(a===b); // 결과값이 false
 
 ```

 Js에서는 서로 다른 자료형일 때도 비교하는것이 가능한데 만약에 string과 number를 비교 하더라도 자료형 제외하고 내부 데이터값만 비교해서 true를 도출하는 경우가 있습니다. 
 == : a와 b의 값이 같은지를 비교함. 정확하게는 string인 b를 number로 바꿔서 비교하여 true return 
 === : a와 b의 값 뿐만 아니라 자료형까지 비교함.  != : 서로 다른지 비교 !== : 자료형까지 확인하여 다른지 비교 > < >= <=


 #### 산술 연산자 
 ++
 --
 #### 논리 연산자 
 and && 
 or || 
 !: 변수 앞에 ! 써서 true `<->` false로 서서 반전시킵니다.

 ### 문자열 연산자
 +만 적용됨

 #### 삼향 연산자(JS에서 더 자주 쓴다고 했었습니다.)
 형식
 ```js
 //조건 ? 값1 : 값2;
 let age = 18;
 let isAdult = (age >= 20) ? true : false;  // 조건이 true면 true return, 아니면 false return 
 // is로 시작하면 보통 boolean 자료형이라고 했었습니다. 

 //심화
 // 조건1 ? 값1 : 조건2 ? 값2 : 값3;
 let point = 92;
 let grade = (point >= 90) ? 'A' : (point >= 80) ? 'B' : 'C';
 console.log(grade);
 ```

 ## 조건문
 1. if문(if / else if / else 포함해서 한꺼번에 하겠습니다)
 02_condition.html

 2. switch문 
 03_condition_switch.html
 작성방식은 Java와 같습니다. 
 
 ## 반복문 
 반복문은 조건을 만족하는 동안 코드 블록을 반복적으로 수행합니다. js에서는 for / for-in / for-of / while과 같은 반복문을 지원합니다. 

 
 04_loop.html 

 1. for-loop
  - Java와 같습니다.

2. for-in
- for-in문은 데이터 타입중 배열뿐만 아니라 객체에도 사용할수 있는 반복문입니다. index넘버를 사용하지 않고 key를 통해서 읽는 방식입니다. 
형식: `for(const key in object명) { 실행문 };` 


3. for-of문

4. while문
-일반 while: Java랑 똑같습니다.

```js
let j = 1;
do {
  console.log(j);
  j++
} while (j <= 10);

```
사실 막 엄청나게 자주쓰진 않는데, 일반 while문의 경우 조건식이 true인지 false 인지 확인하고, true일때만 코드 블럭을 실행합니다. 반면에 do-while문의 경우에는 우선 코드블럭을 한번 실행합니다. 그리고 이후에 조건식을 확인하게 되는데, 이는 "무조건 한번은 실행 하는것"을 담보하기 위해서 입니다. 

형식
```js
do {
  실행문;
} while (조건식);

```
정처기에 나온적 있어서 적어봤습니다. Java버전 역시 동일합니다. 

for - 반복 횟수가 명확할 때
while - 몇번 반복할지 모를때

## 함수(function)
- 아마 오늘 수업 중 제일 중요 
### 정의 
일반적으로 프로그래밍 언어에서는 특정 작업을 여러 번 반복해야 하는 경우, 해당 작업을 "재사용 가능 구조"로 만들게 되는데, 이 때 사용하는 개념이 함수, 함수로 구현된 코드는 그 함수를
"호출" 함으로써 반복된 기능을 쉽게 처리할수 있도록 함.
Js에서는 특별한 경우는 제외하고는  기능에 따라 함수를 작성하며, 함수 안에 Js프로그램 코드를 구현하게 됨. 

-즉, 특정한 기능을 수행하기 위한 일련의 코드 블록을 하나의 실행 단위로 생성한 것.

### 함수 정의(선언) 및 사용

형식

```js
function 함수명(매개변수1, 매개변수2) {
  let 지역변수 = 데이터; 
  return 결과값: 
}
```
-함수 선언 키워드 function
-함수명
-매개변수(optional)
-실행문에 해당하는 코드 블럭(함수 내에서 다른 함수를 호출하는것도 가능)
-결과값(optional)

예시
```js
function sum(x,y) {
  let sum = x + y;
  return sum;
}

sum(10,20);   //결과값이 30, 이지만 console에 출력 안되겠네요, 그렇다면
console.log(sum(10, 20));
```
06_function.html


### 함수 표현식
- "변수에 함수를 할당" 해서 사용하는 방식 

형식

```js
let 변수명 = function(매개변수1, 매개변수2) {
  let 지역변수 = 매개변수1, 매개변수2이 가지고 어쩌고 연산
  실행문
  return 결과값;
}

// 함수 표현식 예시 
let sum = function(x,y) { // 지역변수
  let result = x + y; // 실행문
  return result; // result는 실행문의 결과값. 
}

// 원래 함수 선언 방식
function sum (x,y) {
  let sum = x + y ;
  return sum;
}

//함수 호출 방식
sum(10, 20);
```

굳이 함수 표현식이라는 개념이 나온 이유 역시 var가 일으키는 문제와 유사합니다. 기존의 함수 선언 방식과 선언자 var의 경우에는, Js가 코드를 읽어들일때, 일단 var / function으로 되어있는
애들을 미리 메모리에 올려둡니다. 그 의미는 일단 먼저 변수/함수를 사용(호출)하고 나중에 선언/정의를 하더라도 문제가 없다는 것을 말합니다. 그래서 var선언자 및 function 키워드는 hoisting라는 특징으로 설명됩니다. 근데 var는 문제가 생길수 있음을 얘기했죠. 당연히 우리는 var를 사용한다면 변수를 처음 선언할 때만 쓰는걸로 알고있는데 나중에 사용이 가능하니까요.

그렇다면, var의 문제처럼 function명 역시 동일하다면 더 밑에 정의된 애로 덮어쓰기가 되기 때문에 함수명이 겹치면 개발자가 원하는 결과값이 나오지 않을거라느 의미도 됩니다. 

이상을 이유로 function을 let에 등록을 하게 되면 코드가 순서대로 동작한다는 점에 착안하여 함수 표현식 개념이 등장하게 되었습니다. hoisting 때문에 함수 표현식이 등장했고, 이를 통해 담보할수 있는 것은 "코드가 순서대로" 실행된다는 점입니다. 함수를 담고 있는 변수에 대한 코드 구문이 함수를 호출하는 코드 구문보다 뒤에 있다면 오류가 발생하게 됩니다. 

```js
let sum1 = sum(21, 22);   // 오류 발생
let sum2 = sum(34, 15);   // 오류 발생

let sum = function(x, y) {    // 얘가 함수 '표현식'이기 때문에
  return x + y ;
}
```

### Function 생성자 함수
-Js 내장 함수인 Function 함수에 매개변수와 코드블럭을, "문자열"로 순서대로 전달하여 생성.

예시 
```js
let sum = new Function('x', 'y', 'return x + y');
let sum1 = sum(11, 22);   
let sum2 = sum(22, 33);
```

다음 시간에 간단한 계산기 함수 작성해보겠습니다. 
07_calc.html